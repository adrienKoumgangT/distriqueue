\chapter{Distributed Systems Challenges and Solutions}\label{ch:distributed-systems-challenges-and-solutions}


\section{Synchronization and Coordination Challenges}\label{sec:syncrhonization-and-coordination-challenges}


\subsection{Challenge 1: Leader Election}\label{subsec:challenge-1:-leader-election}

\textbf{Problem}: Multiple orchestrator nodes cannot all act as leaders simultaneously without causing duplicate job assignments.

\textbf{Solution}: \textbf{Raft Consensus Algorithm}.
Implemented in \texttt{raft\_fsm.erl}, using \texttt{gen\_statem}.
The system uses randomized election timeouts to prevent split votes and maintains a strict logical clock (term) to detect stale leaders.


\subsection{Challenge 2: Distributed State Consistency}\label{subsec:challenge-2:-distributed-state-consistency}

\textbf{Problem}: Multiple orchestrator nodes need a consistent view of job states despite network partitions.

\textbf{Solution}: \textbf{CRDT-based Job Registry}.
Implemented in \texttt{job\_registry.erl}, using an Observed-Remove Set (OR-Set) with microsecond timestamps for deterministic conflict resolution.


\subsection{Challenge 3: Dynamic Worker Coordination}\label{subsec:challenge-3:-dynamic-worker-coordination}

\textbf{Problem}: Dynamically assigning jobs to heterogeneous workers (Python/Java) based on real-time load and specific job types (e.g., `calculate` vs `transform`).

\textbf{Solution}: \textbf{Dynamic Polyglot Load Balancer}.
Implemented in \texttt{router.erl}.
Instead of hardcoding worker assignments, the system queries the \texttt{dq\_worker\_pool} to find all workers capable of a specific task type,
calculates their \texttt{current\_load / capacity} ratio, and routes the job to the least loaded node.


\section{Communication Challenges}\label{sec:communication-challenges}


\subsection{Challenge 4: Heterogeneous System Integration}\label{subsec:challenge-4:-heterogeneous-system-integration}

\textbf{Problem}: Components written in Erlang, Java, and Python must communicate seamlessly without tight coupling.

\textbf{Solution}: \textbf{Polyglot Message-Oriented Strategy}.
\begin{itemize}
    \item \textbf{AMQP (RabbitMQ)}: Used for asynchronous job distribution (Gateway $\rightarrow$ Erlang) and status broadcasting (Erlang $\rightarrow$ Gateway).
    \item \textbf{HTTP/REST}: Used by Workers to report completion metrics back to the Erlang API (\texttt{distriqueue\_api.erl}).
    \item \textbf{Erlang Distribution}: Used natively for Inter-node Gossip and Raft coordination.
\end{itemize}


\subsection{Challenge 5: The "Black Hole" Status Problem}\label{subsec:challenge-5:-the-"black-hole"-status-problem}

\textbf{Problem}: Initially, workers pushed statuses directly to the Gateway, bypassing Erlang.
This created a "black hole" where Erlang's internal state became desynchronized from the actual system state.

\textbf{Solution}: \textbf{Erlang as the Single Source of Truth}.
The architecture was refactored so workers report strictly to Erlang via HTTP. Erlang updates its Mnesia/CRDT tables, encodes the complex mathematical results using \texttt{jsx}, and uses the \texttt{rabbitmq\_client.erl} to broadcast a definitive AMQP status payload to the Gateway.

